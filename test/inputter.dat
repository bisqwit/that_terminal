ç¿½Äˆï¸xtosxtosxtosç¿¿}	}	DrawScanline(y, sides[0], sides[1]);// On a single sbkcbk, we go from the left X coordinatebkcbk to the righ.}													: std::tuple(p1,p2, (endy=y2) - y1) );sides[shortside] = std::apply(MakeSlope, (y<y1) ? std::tuple(p0,p1, (endy=y1) - y0)// Recalculate slope for short side. The number of lines cannot be zero.if(y >= y2) break;// If y of p2 is reached, the triangle is complete.{if(y >= endy){for(auto y = y0, endy = y0; ; ++y)// chances that the compiler fails to inline the functor.// there's only one place where DrawScanline() is invoked. This will minimize the// The main rasterizing loop. Note that this is intentionally designed such that	sides[!shortside] = MakeSlope(p0,p2, y2 - y0); // Slope for long side// At this point, y2-y0 cannot be zero.	std::invoke_result_t<decltype(MakeSlope), P*,P*,int> sides[2];// The type of these variables is whatever MakeSlope() returns.// At y = y1, the p0-p1 slope will be replaced with p1-p2 slope.// One of these is on the left side, the other on the right side.// Create two slopes: p0-p1 (short) and p0-p2 (long).	bool shortside = (y1 - y0) * (x2 - x0) < (x1 - x0) * (y2 - y0); // false=left side, true=right side// Determine whether the short side is on the left or on the right.	if(y0 == y2) return;// Early return if there is nothing to draw (triangle has no area)	if(std::tie(y2,x2) < std::tie(y1,x1)) { std::swap(x1,x2); std::swap(y1,y2); std::swap(p1,p2); }if(std::tie(y2,x2) < std::tie(y0,x0)) { std::swap(x0,x2); std::swap(y0,y2); std::swap(p0,p2); }if(std::tie(y1,x1) < std::tie(y0,x0)) { std::swap(x0,x1); std::swap(y0,y1); std::swap(p0,p1); }// Using a 3-input sorting network.// When the Y coordinates are equal, order by X coordinates.// Order (sort) the points by Y coordinate, putting the topmost point first.	auto [x0,y0, x1,y1, x2,y2] = std::tuple_cat(GetXY(*p0), GetXY(*p1), GetXY(*p2));// Do the rasterization from top to bottom.{		 and requires(std::remove_cvref_t<decltype(MakeSlope(p0,p1,1))> a) { DrawScanline(1, a,a); }and requires { { +std::get<1>(GetXY(*p0)) } -> std::integral; }// optional. They just improve code quality.and requires { { +std::get<0>(GetXY(*p0)) } -> std::integral; }// Note: These "requires" lines are totally and (std::tuple_size_v<std::remove_cvref_t<decltype(GetXY(*p0))>> == 2)and std::invocable<decltype(MakeSlope), const P*, const P*, int>requires std::invocable<decltype(GetXY), const P&> auto&& DrawScanline) // A functor that plots N pixels using the slopes on left and right side.auto&& MakeSlope,	  // A functor that creates a slope between two points, with a number of iterations.auto&& GetXY,	  // A functor that retrieves integer x and y coordinates from a ref to P.(const P* p0, const P* p1, const P* p2, // The three corner vertices, of some type P.void RasterizeTriangletemplate<typename P>#include <type_traits>#include <utility>#include <tupleç¿¿>dfç¿¾(#ifndef bqtRasterizeHHbkcbkinexbos#endifxtosbkwwwwwccbk
"mhmalgoriath.hh"
t,2,>ITt>convertible_to<

bxboskzzzcbkzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
ç¿¿zzz
Polygontaut&& Abitdictional rang ofoints  a vertexbkcbkranges::bidirectional_rangbkcbkpoints)>bkcbkbkcbkd::begin(pos))detd::tbegin(pbkcbkstd::begin(,std::begin(bkcbkd::begin(p)bkcbkdet*bkcbktdebkcbkstd::begin(bkcbkstd::begin( bkcbk)ltype(std::begin(bkccbkp
oç¿¿bkcbkbegin = std::bkcbk(points), endend(points);	ç¿¿// Find the bkccbkpoinftre.bkcbkBeg-most. slopes (l&righ) fromtat is toplboç¿¿ç¿¿// Also fbkcbkbkcccbkbotomrigrtex;bkcbk vatâ€™s wher rendering ends.ç¿¿bkcbkfirst, lastbkcbkminmax_element(points.begin(), points.end(),	[&](const auto& ebkcbklem, prv){	});
ppbkcbkrevelem));cc
);ppbkcbkreturn ccbkcbk 
or MakeSlope() bkcbk t(firs1))ltastt{}	// Figure out the winding direction. Clockwise or counterforwards?decltype(Sum(GetXY(*begin))) x0,y0, x1,y1, x2,y2, confidence{}, threshold=1;ç¿¿//bkcbk)) does the same as std::common_type_t between elements, but in much shorter code.ç¿¿ç¿¿// Because of rounding artifacts in clipping, it is possible that we may getç¿¿ç¿¿// contradictory results from (a,b,c) and (b,c,d) for a four-corner polygon.ç¿¿ç¿¿// We choose the bend that has the strongest indication of directionality.ç¿¿if(auto tag = begin; tag != end) { std::tie(x0,y0) = GetXY(*tag);bkcbk  bkcbk ++    11bkcbk
whle{}}}	std::tie(x2,y2bkcbkstd::tie(xbkcbk0,y0)=1,y1);std::tie(x1,y1bkcbk2,y2);bkcbk
   autonec di-if(std::abs(bkcbkbkcbk) > confience))	bkcbk = bkcbk;ç¿¿// If all vertices werebkcccbkfeyparalll, o th than thre, we cannot render.ç¿¿if(std::abs(confidence) < threshold) return;int forwards = confidence < 0;xtoswtemplate<int AssumedWinding = 0>z	int forwards;if constexpr(AssumedWbkcbk== 0){}kb.bkoelse{}	forwards = AssumedWinding > 0;if(begin == end) { return; }// User explicitly requested support for one kind of windings only. Skip testing.ç¿¿
// We donâ€™t need to render anything that has less than three points,ç¿¿ç¿¿
// but the bkccbkalgorihm inis function will produccorrect results even withou check.ç¿¿ç¿¿
// If the user supplied iterators to e.g. std::list<>, using std::distance() would not be cheap here.ç¿¿ç¿¿
// We do have tobkcccbkest fr an empty range, bcause we explicitly try dereferencr.at least one iteraç¿¿xboszzzzzzzzzzzzzzzzzzzzzzz    std::array cur { first, first };auto y = [&](int side) -bkcbk> { returnbkcbk]get<1>(GetXY(*cur[;};)bkcbkinbkcbkt !=t last;  = 0, cur(side)ext[2]{cur,cury} dfç¿¾<zzzzzzzzzzzzzzzz		// We hbkcccccbkd). "sidbkccbktnext bend is.avreaca bend on eitr(or bot" indicates which// In the bkcccbkloop,beginning ofbkcbkbo sides hav(top-left corner of polygon).bkcbkat sbkcccccbkisibkccccbkse lefide,en withourenderinganying, procehe rigde.uation,we firproce	ç¿¿ // Now check whether to go forwards or backwards in the circular chain of points.ç¿¿ç¿¿ auto prev = std::move(cur[side]);ç¿¿ç¿¿ if(side == forwards) bkcbk = (std::next(prev)bkcbk == end) ? begin : ;ç¿¿ç¿¿ ebkcbklsend bkccbk bkcbkstd::prev(prev ==bkcbk? : prev);ç¿¿	next[side]  = y(side);sidebkccbk]],bkcbk[s= MakeSlope(prev, cur[- cury);// Identify which side the next bend is going to be, by choosing the smaller Ybkcbkside = (next[0] <= next[1]) ? 0 : 1;
ss untilbkcbk.tProcetfor(int limit = next[side]; cury != limit; ++cury)	curç¿½Ã¥ğ–“xtoswwww dfç¿¾P