#ifdef RUN_TESTS
# include <gtest/gtest.h>
#endif

/** @file file/share.cc
 * @brief Facilities for finding share-files (files supplied with program)
 * and cache-files (files generated by program).
 */

#include <filesystem>
#include <optional>
#include <fstream>
#include <string_view>
#include <string>
#include <vector>

#include <unistd.h> // For getuid()

#include "share.hh"

using std::filesystem::path;

static const char* arg0 = nullptr;
static path arg0_path;

void SaveArg0(const char* a)
{
    arg0 = a;

    path p = arg0;
    arg0_path = std::filesystem::canonical(p).parent_path();
}

/*
std::pair<path, std::filesystem::file_status>
    FindShareFile(std::string_view file_to_find, std::initializer_list<std::string_view> extra_paths)
{
    return FindShareFile( std::filesystem::path(file_to_find), std::move(extra_paths));
}
*/

template<typename T, typename V>
static std::pair<path, std::filesystem::file_status> FindFileCommon(
    const std::filesystem::path& file_to_find,
    V&& components,
    T&& try_path_fun)
{
    path first;
    std::vector<path> specifics;
    bool has_first = false;
    for(auto s: components)
    {
        if(!has_first)
        {
            first = s;
            has_first = true;
        }
        else if(!s.empty())
            specifics.emplace_back(s);
        else
        {
            if(!first.empty())
            {
                try {
                    auto temp = try_path_fun(first, specifics);
                    if(temp.has_value())
                    {
                        return std::move(temp).value();
                    }
                } catch(...)
                {
                }
            }
            has_first = false;
            specifics.clear();
        }
    }
    return { file_to_find, std::filesystem::status(file_to_find) };
}

std::pair<path, std::filesystem::file_status>
    FindShareFile(const std::filesystem::path& file_to_find,
                  std::initializer_list<std::string_view> extra_paths)
{
    std::vector<std::pair<path, std::vector<path>>> tries;

    const char* file    = file_to_find.c_str();
    const char* homedir = std::getenv("HOME"); if(!homedir) homedir="";
    const char* user    = std::getenv("USER"); if(!user)    user="";
    const char* name    = "that_terminal";
    std::vector<std::string_view> components
    {
        arg0_path.c_str(), "share",              file, "",
        homedir,           ".local/share", name, file, "",
        "/home", user,     ".local/share", name, file, "",
        "/usr/local/share",                name, file, "",
        "/usr/share",                      name, file, "",
    };
    for(auto s: extra_paths)
        components.insert(components.end(), std::initializer_list<std::string_view>{s, file, ""});

    using o = std::optional<std::pair<path, std::filesystem::file_status>>;
    return FindFileCommon(file_to_find, std::move(components),
        [](path test, const std::vector<path>& com) -> o
        {
            /* Append all directory components */
            for(auto i = com.begin(); i != com.end(); ++i)
                 test /= *i;

            auto status = std::filesystem::status(test);
            if(std::filesystem::exists(status))
                return o{ std::in_place_t{}, std::move(test), std::move(status) };
            return {};
        });
}

std::pair<path, std::filesystem::file_status>
    FindCacheFile(const std::filesystem::path& file_to_find, bool is_file)
{
    const char* file    = file_to_find.c_str();
    const char* homedir = std::getenv("HOME"); if(!homedir) homedir="";
    const char* user    = std::getenv("USER"); if(!user)    user=".";
    const char* name    = "that_terminal";
    std::string uid = std::to_string(getuid());
    std::string pu  = name + std::string("-") + uid;
    auto temp       = std::filesystem::temp_directory_path();

    std::array<std::string_view,23> components
    {
        homedir,           ".cache", name, file, "",
        "/home", user,     ".cache", name, file, "",
        "/run/user",        uid.c_str(),   file, "",
        "/run",             uid.c_str(),   file, "",
        temp.c_str(),       pu.c_str(),    file, ""
    };

    using o = std::optional<std::pair<path, std::filesystem::file_status>>;
    return FindFileCommon(file_to_find, std::move(components),
        [is_file](path test, const std::vector<path>& com) -> o
        {
            std::error_code err;
            /* Append all directory components */
            for(auto i = com.begin(); i != com.end(); ++i)
                if(!is_file || std::next(i) != com.end())
                    test /= *i;

            std::filesystem::create_directories(test, err);
            auto status = std::filesystem::status(test);
            if(!err && std::filesystem::exists(status))
            {
                if(!is_file && std::filesystem::is_directory(status))
                    return o{ std::in_place_t{}, std::move(test), std::move(status) };
                if(is_file)
                {
                    /* Test if the file exists in this directory */
                    auto test2 = test / *std::next(com.begin(), com.size()-1);
                    status = std::filesystem::status(test2);
                    if(std::filesystem::exists(status) && !std::filesystem::is_directory(status))
                        return o{ std::in_place_t{}, std::move(test2), std::move(status) };

                    /* Test if the file could be created in this directory */
                    std::ofstream testfile(test2);
                    auto status2 = std::filesystem::status(test2);
                    /* Return the old status, before it existed */
                    if(std::filesystem::exists(status2))
                        return o{ std::in_place_t{}, std::move(test2), std::move(status) };
                }
            }
            return {};
        });
}

#undef try_path

#ifdef RUN_TESTS
static void RunTests()
{
    // Reconstruct a plausible argv[0].
    char Buf[4096]{};
    getcwd(Buf, sizeof(Buf)-1);
    strcat(Buf, "/test");
    SaveArg0(Buf);

    // These tests do not actually test anything,
    // except that the program does not crash.
    // They exist for coverage purposes.

    FindShareFile("unicode/UnicodeData.txt", {"/usr/local/share", "/usr/share"});
    FindShareFile("notfound.txt", {"/abc"});
    FindShareFile("notfound.txt", {});
    FindCacheFile("deleteme.dat", false);
    FindCacheFile("similarities.dat", true);
    FindCacheFile("similarities.dat", false);

    {auto [path, status] = FindCacheFile("deleteme.dat", true);
    if(std::filesystem::exists(status)) //LCOV_EXCL_BR_LINE
    {
        std::filesystem::remove(path);
    }}
    {auto [path, status] = FindCacheFile("similarities.dat", true);
    if(std::filesystem::exists(status)) //LCOV_EXCL_BR_LINE
    {
        std::filesystem::remove(path);
    }}
}
TEST(fileshare, sharetest)
{
    RunTests();
    static std::string home = std::string("HOME=") + getenv("HOME");
    static std::string user = std::string("USER=") + getenv("USER");
    putenv(const_cast<char*>("HOME")); RunTests();
    putenv(const_cast<char*>("USER")); RunTests();
    putenv(const_cast<char*>(home.c_str()));
    putenv(const_cast<char*>(user.c_str()));
}
#endif
